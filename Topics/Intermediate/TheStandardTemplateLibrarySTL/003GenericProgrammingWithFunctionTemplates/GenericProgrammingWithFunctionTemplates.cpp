/*
  Generic Programming with Function Templates

 -----------------------------------------
 Function template with the max function
 -----------------------------------------
 max function
  function to determine the max of 2 integers. for floats, double, char, long there will be little modifiction in max fucntion. The function is same, just the type (of parameters) is changed so many versions of max depending on type.
  Generic Programming - use max with any data types
 */

#include <iostream>

// So now let's see how we can use templates to allow to write just one 
// blueprint for this function.
// max function as a template function
// We can replace type with an identifier/name that represents any type, say T 
// (but we can use any valid identifier we wish)
// T max (T a, T b) {
//   return (a>b) ? a : b;
// }
// But the computer won't know what to do with this, and it's going to give us
// a compiler error. We need to explicitly tell the compiler that this is a 
// template function.
template <typename T> // OR template <class T> 
// typneme T is template parameter type. 
//    This tells a computer the T is the type name that will be replaced with 
//    whatever the user needs.
// We may also use class instead of typeneme. typename and class are equivalent
T max (T a, T b) {
  return (a>b) ? a : b;
}
// Now this will compile, but it will not generate any code. Its simply a 
// template or a blueprint. Code is not generated by the compiler until the 
// user uses a specialized version of the template.

// We can use ALMOST any type we need.
//    Notice that the code in the template function is using the > operator to 
//    compare a and b. This means that whatever type we use for T must support 
//    > operator. For primitive types, like int, chars and doubles, it's not a 
//    problem. But for our own class types, we have to be sure that our class 
//    overloads the greater than operator or this won't compile.

// // We can have multiple template parameters (no limit) and their types can be 
// // different.
// template <typename T1, typename T2> // function declaration - We have specified two template parameters in this case.
// void func(T1 a, T2 b){ // It expects 2 parameters. The first is a type T1 and the second is of type T2.
//   std::cout << a << " " << b;
// }

int main (){

  int a {10};
  int b {20};

  std::cout << max<int>(a,b) << std::endl; // usage of template parameter int- This gives the
  // compiler all the information it needs to actually generate a specialized 
  // function from the template we created using int in place of T. 
  // this happens at compile-time.
  // similar syntax as vectors and smart pointers, unique pointer, shared pointers.
  // as these are implimented as template classes. 

  double c {20.1};
  double d {21.2};
  std::cout << max<double>(c,d) << std::endl; // max function for doubles.
  // The compiler now knows that it needs to generate the double version of 
  // the max function.

  // Often, the compiler can deduce the type and the template prarameter is not 
  // needed. (and we don't even need to provide it as in the second statement.)
  // Depending on the type of c and d, the compiler will figure it out.
  std::cout << max(c,d) << std::endl; // for doubles 

  // max function - char
  char e {'A'};
  char f {'Z'};

  std::cout << max(e,f) << std::endl; // the compiler will generate the character version of max fucntion.

  // // Assuming player class
  // Player p1{"Hero", 100, 20};
  // Player p2{"Enemy", 99, 3};

  // // using max with player objects 
  // // The compiler will generate the max function that expects and compares
  // // player objects.
  // std::cout << max<Player> (p1,p2); 
  // // This will not compile unless Player class overloads > operator

  // // usage - after operator overloading
  // func<int, double> (10, 20.2); // explicitly provide an integer in the double
  // func('A', 12.4); // call of func with no template parameters, the compiler 
  // // will deduce the types from the function arguments.
  // // we can pass by value, by reference, by pointer with const modifiers and so forth and all of the function parameters dont have to be generic. 

  return 0; 
}