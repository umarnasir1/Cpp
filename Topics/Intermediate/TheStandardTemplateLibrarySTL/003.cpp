/*
  Generic Programming with Function Templates
    Generic functions using Function Templates.
*/

// -----------------------------------------
// Function template with the max function
// -----------------------------------------

// max function
// function to determine the max of 2 integers. for floats, double, char, long there will be little modifiction in max fucntion. The function is same, just the type (of parameters) is changed so many versions of max depending on type.
// Generic Programming - use max with any data types

int max (int a, int b){
  return (a > b) ? a : b;
}

int max (double a, double b){
  return (a > b) ? a : b; // conditional operator
}

int max (char a, char b){
  return (a > b) ? a : b; // conditional operator
}

int x {100};
int y {200};
std::cout << max(x,y); // 200

// So now let's see how we can use templates to allow to write just one blueprint for this function.
// max function as a template function
// We can replace type we want to generalize with a name, say T (but we can use any valid identifier we wish)
T max (T a, T b) {
  return (a>b) ? a : b;
}
// But the computer won't know what to do with this, and it's going to give us a compiler error. We need to explicitly tell the compiler that this is a template function.
template <typename T> // OR template <class T> - We need to tell the compiler that this is a template function. This tells a computer the T is the type name that will be replaced with whatever the user needs. // We may also use class instead of typeneme.
T max (T a, T b) {
  return (a>b) ? a : b;
}
// Now this will compile, but it will not generate any code. Its simply a template or a blueprint. Code is not generated by the compiler until the user uses a specialized version of the template.


// -----------------------------------
// How to use that template function
// -----------------------------------
int a {10};
int b {20};


std::cout << max<int>(a,b); // usage of template parameter -- This gives the compiler all the information it needs to actually generate a specialized function from the template we created usint int in plate of T.

std::cout << max<double>(c,d); // max function for doubles. The compiler now knows that it needs to generate the double version of the max function.

// Often the compiler can deduce the type of the template prarameter is not needed.
// Depending on the type of a and b, the compiler will figure it out.

std::cout << max(c,d);

// max function - char
char a {'A'};
char b {'Z'};

std::cout << max(a,b) << std::endl; // the compiler will generate the character version of max fucntion.

// We can use ALMOST any type we need.
//    Notice that the code in the template function is using the > operator to compare a and b. This means that whatever type we use for T must support > operator. For primitive types, like int, chars and doubles, it's not a problem. But for our own class types, we have to be sure that our class overloads the greater than operator or this won't compile.

// Assuming player class
Player p1{"Hero", 100, 20};
Player p2{"Enemy", 99, 3};

std::cout << max<Player> (p1,p2); // This will not compile unless Player overloads > operator

// We can have multiple template parameters (no limit) and their types can be different.
template <typename T1, typename T2> // function declaration - We have specified two template parameters in this case.
void func(T1 a, T2 b){ // It expects 2 parameters. The first is a type T1 and the second is of type T2.
  std::cout << a << " " << b;
}

// usage
func<int, double> (10, 20.2); // explicitly provide an integer in the double
func('A', 12.4); // the compiler will deduce the types from the function arguments.
// we can pass by value, by reference, by pointer with const modifiers and so forth and all of the function parameters dont have to be generic. 
